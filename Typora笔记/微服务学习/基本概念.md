##一、服务雪崩效应

1.假设我们有两个访问量比较大的服务A和B，这两个服务分别依赖C和D,C和D服务都依赖E服务

![img](https://img2018.cnblogs.com/blog/342595/201906/342595-20190610131912036-685110539.png)

2.A和B不断的调用C,D处理客户请求和返回需要的数据。当E服务不能供服务的时候，C和D的`超时`和`重试`机制会被执行，超时等待时间过长，一直堆积

![img](https://img2018.cnblogs.com/blog/342595/201906/342595-20190610131857360-406647251.png)

3.由于新的调用不断的产生，会导致C和D对E服务的调用大量的积压，产生大量的调用等待和重试调用，慢慢会耗尽C和D的资源比如内存或CPU，然后也down掉。

![img](https://img2018.cnblogs.com/blog/342595/201906/342595-20190610131927577-137399041.png)

4.A和B服务会重复C和D的操作，资源耗尽，然后down掉，最终整个服务都不可访问。



![img](https://img2018.cnblogs.com/blog/342595/201906/342595-20190610131941391-893905675.png)

##二、常见的导致雪崩的情况有以下几种：

- 程序bug导致服务不可用，或者运行缓慢
- 缓存击穿，导致调用全部访问某服务，导致down掉
- 访问量的突然激增。
- 硬件问题，这感觉只能说是点背了⊙︿⊙。

##三、解决办法

#### （1）限流

限制客户端的调用来达到限流的做法是很常见的，比如，我们限制每秒最大处理200个请求，超过个数量直接拒绝请求。常见的算法如[令牌桶算法](https://baike.baidu.com/item/令牌桶算法/6597000?fr=aladdin)
以一定的速度在桶里放令牌，当客户端请求服务的时候，要先从桶里得到令牌，才能被处理，如果桶里的令牌用完了，则拒绝访问。

![img](https://img2018.cnblogs.com/blog/342595/201906/342595-20190610132002408-1100756871.png)

#### （2）熔断

在客户端控制对依赖的访问，如果调用的依赖不可用时，则不再调用，直接返回错误，或者降级处理。开源的库比如[hystrix-go](https://github.com/afex/hystrix-go)，也是我接下来要写的源码分析的一个库。很好的实现了熔断和降级的功能。他的主要思想是，设置一些阀值，比如，最大并发数，错误率百分比，熔断尝试恢复时间等。能过这些阀值来转换熔断器的状态：

- 关闭状态，允许调用依赖
- 打开状态，不允许调用依赖，直接返回错误，或者调用fallback
- 半开状态，根据`熔断尝试恢复时间`来开启，允许调用依赖，如果调用成功则`关闭`失败则继续`打开`

![img](https://img2018.cnblogs.com/blog/342595/201906/342595-20190610131551388-11358088.png)

###### 1.配置注释

```yml
hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 9000 #设置超时时长
      circuitBreaker:
        requestVolumeThreshold: 5   #  10秒种访问5次都失败的话, 会断开服务,不调用方法,直接进入fallback
        sleepWindowInMilliseconds : 5000   #默认是5秒 5秒后尝试再访问一次服务器
feign:
  hystrix:
    enabled: true #开启feign当中的hystrix        
```

